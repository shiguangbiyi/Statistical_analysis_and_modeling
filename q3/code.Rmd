---
title: "time_analyse"
author: "yjy"
date: "2023-12-06"
output: word_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

读取数据
```{r 读取数据}
raw_data<-read.table("./stock.csv",header=TRUE,sep=",")
summary(raw_data)#检查数据类型
```

数据处理
```{r 数据处理：发现有些数据类型不对，所以进行处理 首先处理公司和时间}
data<-data.frame(matrix(nrow = nrow(raw_data), ncol=ncol(raw_data)))#新建一个空的数据框，用于存储处理后的数据
colnames(data) <- colnames(raw_data)
data$Company<-as.factor(raw_data$Company)#把公司代码转为因子类型
raw_data$Date<-gsub("-", "/", raw_data$Date)#把这一列的-都替换成/
data$Date<-as.Date(raw_data$Date, format = "%m/%d/%Y")#在表格中的存储样式是：07/17/2023
summary(data$Date)#检查是否有缺失值
cat("\n")
summary(data$Company)
```

```{r 处理4列价格}
raw_data$Close.Last<-gsub("\\$", "", raw_data$Close.Last)#把这一列的$都删掉
data$Close.Last<-as.numeric(raw_data$Close.Last)#转换类型
raw_data$Open<-gsub("\\$", "", raw_data$Open)
data$Open<-as.numeric(raw_data$Open)
raw_data$High<-gsub("\\$", "", raw_data$High)
data$High<-as.numeric(raw_data$High)
raw_data$Low<-gsub("\\$", "", raw_data$Low)
data$Low<-as.numeric(raw_data$Low)

data$Volume<-raw_data$Volume
data<-data[order(data$Date),]#按日期排序
summary(data)#再次检查数据类型以及检查是否有空值
```
将各公司的数据全部转换为时间序列类型，以便之后更好地做数据处理
```{r 提取各个公司的数据，转为ts类型}
# 创建一个连续时间序列
end_date <- tail(data$Date,n=1)
start_date <- head(data$Date,n=1)
all_dates <- seq(start_date, end_date, by = "day")

#单独取出各个公司的数据进行分析
data_AAPL<-subset(data,Company=="AAPL")
data_AMD<-subset(data,Company=="AMD")
data_AMZN<-subset(data,Company=="AMZN")
data_CSCO<-subset(data,Company=="CSCO")
data_META<-subset(data,Company=="META")
data_MSFT<-subset(data,Company=="MSFT")
data_NFLX<-subset(data,Company=="NFLX")
data_QCOM<-subset(data,Company=="QCOM")
data_SBUX<-subset(data,Company=="SBUX")
data_TSLA<-subset(data,Company=="TSLA")
company_data <- list(
  data_AAPL,
  data_AMD,
  data_AMZN,
  data_CSCO,
  data_META,
  data_MSFT,
  data_NFLX,
  data_QCOM,
  data_SBUX,
  data_TSLA
)
#把各公司的数据转为ts
ts_list<-list()
for(i in 1:length(company_data)){
   temp_ts<- ts(data = NA, start = start_date, end = end_date, frequency = 1)
   date_indices <- match(company_data[[i]]$Date, all_dates)
   
   # 将列全部修改为时间序列
   for (col_name in names(company_data[[i]])) {
      # 排除日期列
      if (col_name != "Date") {
         temp_ts[date_indices] <- company_data[[i]][, col_name]
         ts_list[[length(ts_list) + 1]] <- temp_ts
      }
   }
# temp_ts[date_indices] <- company_data[[i]]$Close.Last#注意这里只把收盘价填入了ts
# ts_list[[length(ts_list) + 1]]<-temp_ts
}

```

```{r 清除工作空间的多余内容}
#rm(season_ts)
#remove.packages("ggplot2")
#install.packages("htmltools", version = "0.5.7")
install.packages("ggplot2")
```

初步分析
为了后期更好的建模，首先使用可视化手段对数据进行初步分析。
```{r 下载需要的包}
#install.packages("pacman")
#install.packages("lubridate")
#install.packages("RColorBrewer")
#install.packages("plotly")
```

这个部分可以不要？？
```{r 画收盘价的图}
library(ggplot2)
library(pacman)
library(lubridate)
library(RColorBrewer)
fig1_col <- brewer.pal(n = 10, name = "Paired")
#参考自：https://zhuanlan.zhihu.com/p/35366657
#画图
plot(ts_list[[1]], xaxt = "n", main = "各公司的收盘价随时间变化图", xlab = "时间", ylab = "收盘价",col=fig1_col[1],ylim = c(0, 800))#画ts，但先不画出坐标轴
for(i in 2:length(ts_list))
{
  lines(ts_list[[i]], xaxt = "n",col=fig1_col[i])
}

axis(1, at = seq(start_date- years(1), end_date+ years(1), by = "year"), labels = format(seq(start_date- years(1), end_date+ years(1), by = "year"), "%Y"))#添加年份作为坐标轴
legend_text <- c("AAPL", "AMD","AMEN","CSCO","META","MSFT","NFLX","QCOM","SBUX","TSLA")  # 自定义图例文本
legend("topleft", legend = legend_text, col = fig1_col[1:length(ts_list)], lty = 1)  
# 添加图例，并指定对应的颜色# 添加图例，说明每个颜色对应的公司
# 图例太大了，可能需要做相应的调整
```

```{r 对每个公司画K线图}
library(plotly)
plot_ly(company_data[[1]],x=~Date,type="candlestick", open=~Open,close=~Close.Last,
        high=~High,low=~Low,
        increasing=list(line=list(color="red")),
        decreasing=list(line=list(color="green")))
```

Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.
```{r 对Volume这个属性画柱形图}
library(ggplot2)
ggplot(subset(data,Date>=as.Date("2023-06-01")), aes(x = Date, y = Volume, fill = Company)) +
  geom_bar(stat = "identity", position = "stack")+
  scale_fill_manual(values = fig1_col)
#如果要获得某个时间点之后的数据：Date>=as.Date("2023-01-01"),aes(x = Date, y = Volume, fill = Company)
#如果要获得同一天的各个公司比较：aes(x = Company, y = Volume, fill = Company)
```
```{r 做季节性分析}
library(ggseas)
library(ggplot2)
library(forecast)
library(zoo)
# 创建时间序列对象，并将频率设置为12（表示每月）
ts_obj <- na.locf(ts_list[[1]], fromLast = FALSE)
ts_obj <- ts(data = ts_obj, frequency = 12)

# 绘制季节图
seasonplot(ts_obj)


```


相关性分析。
对收盘价进行相关性分析的意义
```{r 相关性分析——数据处理}
# 首先检查我们所取的样本中列出的日期下，是否每个公司都有收盘价的值
library(dplyr)

all_company_close.last <- data %>%
  group_by(Date) %>%
  summarise(
    AAPL = mean(Close.Last[Company == "AAPL"], na.rm = TRUE),
    AMD = mean(Close.Last[Company == "AMD"], na.rm = TRUE),
    AMZN = mean(Close.Last[Company == "AMZN"], na.rm = TRUE),
    CSCO = mean(Close.Last[Company == "CSCO"], na.rm = TRUE),
    META = mean(Close.Last[Company == "META"], na.rm = TRUE),
    MSFT = mean(Close.Last[Company == "MSFT"], na.rm = TRUE),
    NFLX = mean(Close.Last[Company == "NFLX"], na.rm = TRUE),
    QCOM = mean(Close.Last[Company == "QCOM"], na.rm = TRUE),
    SBUX = mean(Close.Last[Company == "SBUX"], na.rm = TRUE),
    TSLA = mean(Close.Last[Company == "TSLA"], na.rm = TRUE),
    # 添加其他公司的收盘价列，以此类推
  )
summary(all_company_close.last)
```
由此可知，样本中的日期，每一个公司都有收盘价，可以直接进行相关性分析。
```{r 相关性分析——数据}
# 反选，选择除了第一列的其他列
# install.packages("Hmisc")
library(Hmisc)
cor_matrix <- 
  rcorr(as.matrix(all_company_close.last[, -1]))
# 查看相关性矩阵和显著性水平
cor_matrix$r
cor_matrix$P
```

```{r 相关性分析——相关性可视化}
# install.packages("corrplot")
# require(corrplot)
# library(corrplot)
# 参考ppt
corrplot(cor_matrix$r,method="pie",type="upper",order="hclust",col=c("darkorange","steelblue"),bg="lightgreen")

```
```{r tseries尝试}
# 尝试使用tseries绘制K线图、建立时间序列模型
# install.packages("tseries")
# library(tseries)

# install.packages("quantmod")
# library(quantmod)

# 首先将输入数据转为ts数据
# chartSeries(data_AAPL)
```

